#!/usr/bin/ruby
require 'atk_toolbox'

# TODO: look into https://piotrmurach.github.io/tty/  to animate the terminal
# TODO: look at https://github.com/pazdera/catpix to add an ATK logo in the terminal

def install(package_name)
    # check for an internet connection
    if not online?()
        puts "\n\nIt seems like you're not online at the moment so I can't install anything"
        return
    end
    # check if the package is alread installed
        # ask if they want to reinstall/update it
    # split up the package name from the version
    # check if it exists in core
    core = YAML.load_file(File.join(Etc.getpwuid.dir, "atk", "core.yaml"))
    if core[package_name] != nil
    # TODO: check if its in approved
    # TODO: check if its in unapproved
    end
    # download the zip file
    # unzip it
    # parse the (installer) field to get OS specific settings
    # TODO: recursively check all of the dependencies
        # install the ones they don't have
        # tell them about the ones that are newer
        # ask them to upgrade the ones that are older
    # run the (install_command)
end

if ARGV.length == 0
    puts "This is the ATK command! I'm glad to see you're using it.\nRunning it with no arguments will just get you this message :)"
# if one argument, then act like grep
else
    case ARGV[0]
        when 'update'
            if ARGV[1] == nil
                if OS.is?('mac')
                    -'eval `curl -L git.io/fjBzd`'
                else
                    raise "OS not yet supported for this command"
                end
            end
        when 'install'
            package_name = ARGV[1]
            # load the core packages
            
            # first check the locally-stored core listing
            # then check the locally-stored main listing
            # then search github for the repo
            
            # once a package is found, save it locally and run it's installer
        when 'uninstall'
            # check to see if the package is installed, and check if it has an uninstaller
        when 'new'
            case ARGV[1]
                when 'project'
                    # create a folder with an info.yaml
                    # ask the user what structure's they would like to integrate
                when 'package'
                    # ask the user what kind of package, installer or structure
                when 'installer'
                    # ask the user what they did to install it
                        # just commands
                        # programming logic
                        # manual setup
                    # repeat for each OS
                when 'structure'
                    # TODO: this is a future feature
                    # structures will can have a
                        # verifier (make sure the structe alread exists)
                        # implementer (make the structure exist if it doesnt)
            end
    end
    
end
